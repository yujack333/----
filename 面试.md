0.手写IOU代码：
```python
def cal_IOU(box1,box2):
    #box1=[x_min,y_min,x_max,y_max]
    #box2 is the same type
    area_box1 = (box1[3]-box1[2])*（box1[1]-box1[0]）
    area_box2 = (box2[3]-box2[2])*（box2[1]-box2[0]）
    
    left = max(box1[0],box2[0])
    up  = max(box1[1],box2[1])
    right = min(box1[2],box2[2])
    down = min(box1[3],box2[3])
    
    union = max(0,(right-left)*(down-top))
    
    iou = union/(area_box1+area_box2-union)
    return iou
    
```
1.手写nms算法
```python
def nms(score,cls,box):
    #score是物体的置信度，维度：[n,1]
    #cls是物体的类别,维度：[n,1]
    #box为物体的框，维度：[n,4]
    indx = np.argsort(score)[::,-1]
    score = score[indx]
    cls = cls[indx]
    box = box[indx]
    
    for i in range(len(score)):
        if score==0:
            continue
        for j in range(i+1,len(score)):
            iou = IOU(box[i],box[j])
            if iou>thresh and cls[i]==cls[j]:
                score[j]=0
    indx = np.nonezero(score)
    score = score[indx[0]]
    cls = cls[indx[0]]
    box = box[indx[0]]
    
    return score,cls,box
```

2.手写roipooling，roialign
```python
def roipooling(bin,feature):
    #bin,type:int,为pooling后的维度 -例如 7
    #feature,type:array,为特征图。维度:[b,w,h,c]
    f_shape = feature.shape
    w_per_bin = int(f_shape[1]/7)
    h_per_bin = int(f_shape[2]/7)
    
    output = np.zeros(shape[0],bin,bin,shape[-1])
    
    for i in range(bin):
        for j in range(bin):
            w_begain = i*w_per_bin
            h_begain = j*h_per_bin
            output[:,i,j,:] = np.max(feature[:,
                                              w_begain:w_begain+w_per_bin,
                                              h_begain:h_begain+h_per_bin,
                                              :],
                                      axis=[1,2],
                                      keepdims=True)
    return output
```





3.BN

4.dropout

5.防止过拟合的方法
